# 第17周-第15章作业

## 15.1证明两阶段封锁协议保证冲突可串行化，并且事务可以根据其封锁点串行化

-   假设：两阶段封锁协议不能确保冲突的可串行化。
    -   那么就存在一组符合两阶段封锁协议，并且不可串行化的事务$T_0,T_1...T_{n-1}$
    -   假设优先图中存在如下循环：$T_0->T_1->T_2->...->T_{n-1}->T_0$
    -   令$a_i$为$T_i$的封锁点，那么有$T_i->T_j,a_i<a_j$
    -   那么对于上面的循环有$a_0<a_1<a_2<...<a_{n-1}<a_0$,但是由于$a_0<a_0$不存在的,所以上述假设循环不存在。
    -   因此两阶段封锁协议，不会出现符合两阶段封锁协议并且不可串行化的事务，所以两阶段封锁协议可以确保冲突客串行化。因为事务的封锁点也是优先图的拓扑排序，所以可以根据其封锁点进行串行化。

## 8.26考虑下面两个事务

~~~
T34:
	read(A);
	read(B);
    if A=0 then B:=B+1;
    write(B);
T35:
	read(B);
	read(A);
	if B=0 then A:=A+1;
	write(A);
~~~

#### 给事务$T_{34},T_{35}$增加加锁、解锁指令，使它们遵从两阶段封锁协议。这两个事务会引起死锁吗？

~~~
T34:
	lock-S(A);
	read(A);
	lock-X(B);
	read(B);
    if A=0 then B:=B+1;
    write(B);
    unlock(A);
    unlock(B);
T35:
	lock-S(B);
	read(B);
	lock-X(A);
	read(A);
	if B=0 then A:=A+1;
	write(A);
	unlock(B);
	unlock(A);
~~~

这两个事务会引起死锁，如果按如下顺序执行：

|  $T_{34}$  |  $T_{35}$  |
| :--------: | :--------: |
| lock-S(A); |            |
|            | lock-S(B); |
|            |  read(B);  |
|  read(A);  |            |
| lock-X(B); |            |
|            | lock-X(A); |

## 15.20严格两阶段封锁协议带来什么好处？会产生哪些弊端？ 

-   **优点：**只产生冲突客串行化调度，并且事务可以根据其封锁点作串行化，同时因为其是无级联调度，所以恢复很容易。
-   **缺点：**降低了并发性。